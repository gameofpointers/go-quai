package vm

import (
	"math/big"
	"testing"

	"github.com/dominant-strategies/go-quai/common"
	"github.com/stretchr/testify/require"
)

type abiEncode struct {
	trancheUnlockHeight uint32
	balance             *big.Int
	elements            uint16
	delegate            common.Address
	err                 string
	expectedEncodedData []byte
}

func TestABIEncodeLockupData(t *testing.T) {

	testCases := []abiEncode{
		// If all zeroes
		{0, big.NewInt(0), 0, common.Address{}, "", make([]byte, 128)},
		// Good case
		{100, big.NewInt(10000000), 34, common.HexToAddress("0x0000000000000000000000000000000000000003", common.Location{0, 0}), "",
			[]byte{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x64, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x98, 0x96, 0x80, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x22, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x3}},
		// Overflowing balance
		{0, new(big.Int).SetBytes([]byte{1, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
			3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3}), 0, common.Address{},
			"balance is too large", make([]byte, 128)},
	}

	for _, test := range testCases {
		endodedData, err := ABIEncodeLockupData(test.trancheUnlockHeight, test.balance, test.elements, test.delegate)
		if err != nil {
			// if the err is not nil, it should have the error specified in the test case
			require.Contains(t, err.Error(), test.err)
		} else {
			require.Equal(t, test.expectedEncodedData, endodedData)
		}
	}
}
